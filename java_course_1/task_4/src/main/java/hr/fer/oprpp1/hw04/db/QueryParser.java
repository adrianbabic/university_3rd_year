package hr.fer.oprpp1.hw04.db;

import java.util.ArrayList;
import java.util.List;

import hr.fer.oprpp1.hw04.db.lexer.QueryLexer;
import hr.fer.oprpp1.hw04.db.lexer.Token;
import hr.fer.oprpp1.hw04.db.lexer.TokenType;

/**	Class used for parsing the given input. If there are valid conditional expressions,
 * 	class then collects them are stores them in an ArrayList.	
 *  
 * 	@author adrian
 */
public class QueryParser {
	
	/** List containing objects of type ConditionalExpression stored by this parser. **/
	private List<ConditionalExpression> expressions;
	/** List containing objects of type Token received by the lexer. **/
	private List<Token> tokens;
	/** Instance of type QueryLexer used for generating tokens. **/
	private QueryLexer lexer;
	
	/** Default constructor which redirects the given String value to the lexer.
	 * 	If the input passes through the lexer, this constructor generates conditional
	 * 	expressions if the given tokens are in correct order.
	 * 
	 * 	@param object of type String	
	 */
	public QueryParser(String input) {
		this.lexer = new QueryLexer(input);
		this.tokens = new ArrayList<>();
		this.expressions = new ArrayList<>();
		generate();
	}
	
	/** Method determines if the given input was a direct query.
	 * 	Direct query should be a single valid conditional expression having an 
	 * 	attribute 'jmbag' and an equals ('=') operator. 
	 * 
	 * 	@return true if query was direct
	 * 	@return false if query was not direct
	 */
	public boolean isDirectQuery() {
		if(expressions.size() == 1 && tokens.get(0).getValue().equals("jmbag") && tokens.get(1).getValue().equals("="))
			return true;
		return false;
	}
	
	/** Method returns String representing a 'jmbag' value if the query was a direct one.
	 * 
	 * 	@throws IllegalStateException if the method is called and query was not a direct one
	 * 	@return object of type String
	 */
	public String getQueriedJMBAG() {
		if(isDirectQuery())
			return tokens.get(2).getValue();
		else
			throw new IllegalStateException("Query was not a direct one!");
	}
	
	/** Method returns a reference to a list containing objects of type ConditionalExpression
	 * 
	 * 	@return reference to a List<ConditionalExpression>
	 */
	public List<ConditionalExpression> getQuery(){
		return expressions;
	}
	
	/** Method calls the lexer for generating tokens. If lexer does not throw an exception,
	 * 	method tries to generate conditional expressions. Should the input be valid, this method will
	 * 	store all the generated conditional expressions in the list containg object of type 
	 * 	ConditionalExpression.
	 * 
	 * 	@throws IllegalStateException if the conditional expression is not valid
	 * 		(valid conidtional expression should consist of an attribute, followed by operator, followed
	 * 		by string literal)
	 * 		in that precise order)
	 * 	@throws IllegalStateException if there is not a Token whose TokenType is LOGICAL_OPERATOR 
	 * 	between conditional expressions
	 * 	@throws IllegalStateException if a single conditional expression has not been generated
	 * 		(if there was less than three token generated by the lexer)
	 */
	private void generate() {
		Token currentToken = lexer.nextToken();
		while(currentToken.getType() != TokenType.EOQ) {
			tokens.add(currentToken);
			if(tokens.size() == 4) {
				if(currentToken.getType() != TokenType.LOGICAL_OPERATOR) 
					throw new IllegalStateException("There should be a logical operator between conditional expressions!");
				else 
					tokens.clear();
			}
			if(tokens.size() == 3) {
				Token attribute = tokens.get(0);
				Token operator = tokens.get(1);
				Token stringLiteral = tokens.get(2);
				if(attribute.getType() != TokenType.ATTRIBUTE || operator.getType() != TokenType.OPERATOR 
						|| stringLiteral.getType() != TokenType.LITERAL) {
					throw new IllegalStateException("Given conditional expression is not in valid order!");
				} else {
					expressions.add(new ConditionalExpression(
							getFieldValueGetter(attribute.getValue()), stringLiteral.getValue(), 
							getComparisonOperator(operator.getValue())));
				}
			}
			currentToken = lexer.nextToken();
		}
		if(expressions.isEmpty())
			throw new IllegalStateException("Expected at least one conditional expression!\nHINT: In a query, attribute should be"
					+ " followed by operator and operator should be followed by string literal.");
		
	}
	
	/** Method determines which implementation of IComparisonOperator the given String is supposed to represent.
	 *
	 *	@param object of type String
	 *	@return object of type IComparisonOperator 
	 *	@throws IllegalStateException if the given String does not represent any supported implementations
	 *		of IComparisonOperator
	 */
	private IComparisonOperator getComparisonOperator(String value) {
		switch (value) {
		case "LIKE":
			return ComparisonOperators.LIKE;
		case "<":
			return ComparisonOperators.LESS;
		case "<=":
			return ComparisonOperators.LESS_OR_EQUALS;
		case ">":
			return ComparisonOperators.GREATER;
		case ">=":
			return ComparisonOperators.GREATER_OR_EQUALS;
		case "=":
			return ComparisonOperators.EQUALS;
		case "!=":
			return ComparisonOperators.NOT_EQUALS;
		default:
			throw new IllegalStateException("Operator symbol is not valid!");
		}
	}
	
	/** Method determines which implementation of IFieldValueGetter the given String is supposed to represent.
	 *
	 *	@param object of type String
	 *	@return object of type IFieldValueGetter
	 *	@throws IllegalStateException if the given String does not represent any supported implementations
	 *		of IFieldValueGetter
	 */
	private IFieldValueGetter getFieldValueGetter(String value) {
		switch (value) {
		case "lastName":
			return FieldValueGetters.LAST_NAME;
		case "firstName":
			return FieldValueGetters.FIRST_NAME;
		case "jmbag":
			return FieldValueGetters.JMBAG;
		default:
			throw new IllegalStateException("Attribute name is not valid!");
		}
	}

}
